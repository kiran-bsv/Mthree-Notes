{"ast":null,"code":"import { BehaviorSubject, interval } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./api.service\";\nexport let AlertsService = /*#__PURE__*/(() => {\n  class AlertsService {\n    apiService;\n    alertsSubject = new BehaviorSubject([]);\n    refreshInterval = 30000; // 30 seconds\n    alerts$ = this.alertsSubject.asObservable();\n    constructor(apiService) {\n      this.apiService = apiService;\n      // Set up automatic polling for alerts\n      this.setupAlertsPolling();\n    }\n    setupAlertsPolling() {\n      interval(this.refreshInterval).pipe(switchMap(() => this.apiService.getAlerts())).subscribe({\n        next: alerts => this.alertsSubject.next(alerts ?? []),\n        error: error => console.error('Error fetching alerts:', error)\n      });\n      // Initial fetch\n      this.refreshAlerts();\n    }\n    refreshAlerts(severity) {\n      this.apiService.getAlerts(severity).subscribe({\n        next: alerts => this.alertsSubject.next(alerts),\n        error: error => console.error('Error fetching alerts:', error)\n      });\n    }\n    acknowledgeAlert(alertId) {\n      const currentAlerts = this.alertsSubject.getValue();\n      const updatedAlerts = currentAlerts.map(alert => alert.id === alertId ? {\n        ...alert,\n        acknowledged: true\n      } : alert);\n      this.alertsSubject.next(updatedAlerts);\n      // In a real app, you would call an API endpoint to persist this change\n      // this.apiService.acknowledgeAlert(alertId).subscribe();\n    }\n    static ɵfac = function AlertsService_Factory(t) {\n      return new (t || AlertsService)(i0.ɵɵinject(i1.ApiService));\n    };\n    static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: AlertsService,\n      factory: AlertsService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return AlertsService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}